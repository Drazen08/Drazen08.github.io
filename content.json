{"meta":{"title":"Drazen","subtitle":"the stack of it nerds","description":"start from zero","author":"JFuncnovic","url":"http://sunjx93.com"},"pages":[],"posts":[{"title":"Mysql 分页整理","slug":"fenye","date":"2018-04-10T05:52:09.000Z","updated":"2018-04-24T08:34:10.530Z","comments":true,"path":"2018/04/10/fenye/","link":"","permalink":"http://sunjx93.com/2018/04/10/fenye/","excerpt":"MySql 分页整理 轻量数据与大量数据的分页完全是两回事，如果没有很好地进行优化，很可能会导致性能的直线下降。现在对mysql分页做一个简单的小整理…","text":"MySql 分页整理 轻量数据与大量数据的分页完全是两回事，如果没有很好地进行优化，很可能会导致性能的直线下降。现在对mysql分页做一个简单的小整理… 最简单的分页 select * from content order by id desc limit 0, 10 当数据量多了一些的时候：select * from content order by id desc limit 1000000, 10 当数据量比较大的时候，这样分页的方案会导致最后几页的查询速度下降。 所以SELECT * FROM table WHERE id &gt;= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10; 因为id是拥有索引的主键，所以，效率会比纯limit高一些 什么是更优解？SELECT * FROM table WHERE id BETWEEN 1000000 AND 1000010; 另：如果找寻的id并不连续，可以先找出id，再用in的方式查询： SELECT * FROM table WHERE id IN(10000, 100000, 1000000...); 另一种方式： FOUND_ROWS() 使用MySql中的函数FOUND_ROWS()，在SELECT中可以得到两个结果： 得到Limit的内容 得到去除Limit以后所有行数 SELECT语句中经常可能用LIMIT限制返回行数。有时候可能想要知道如果没有LIMIT会返回多少行，但又不想再执行一次相同语句。那么，在SELECT查询中包含SQL_CALC_FOUND_ROWS选项，然后执行FOUND_ROWS()就可以了： select SQL_CALC_FOUND_ROWS * FROM tbl_name WHERE id &gt; 100 LIMIT 10; SELECT FOUND_ROWS(); 如果在前一条语句中使用SQL_CALC_FOUND_ROWS选项，FOUND_ROWS()将返回第一条语句没有LIMIT时返回的行数。 如果在前一条语句中没有使用SQL_CALC_FOUND_ROWS选项，FOUND_ROWS()将返回前一条语句实际返回的行数。 如果使用 SELECT SQL_CALC_FOUND_ROWS，MySQL必须计算所有结果集的行数。尽管这样，总比再执行一次不使用LIMIT的查询要快多了吧，因为那样结果集要返回客户端滴。（另外：应该不单是没有将结果集返回的原因，还有原因可能是比如LIKE之类比较费劲的SQL不需要再去劳累一次。） – 注意下面语句中的条件 LIKE SELECT SQL_CALC_FOUND_ROWS * FROM tbl_name WHERE Name LIKE ‘%string%’ id &gt; 100 LIMIT 10; SELECT FOUND_ROWS(); – 上面语句等价于下面语句，但性能方面应该提升非常非常的明显： SELECT COUNT(*) FROM tbl_name WHERE Name LIKE ‘%string%’ ; SELECT * FROM tbl_name WHERE Name LIKE ‘%string%’ id &gt; 100 LIMIT 10;","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://sunjx93.com/tags/Mysql/"}]},{"title":"Linux 下oracle的数据恢复以及数据库命令行安装","slug":"linux_oracle","date":"2017-11-07T08:52:09.000Z","updated":"2017-11-07T07:56:42.228Z","comments":true,"path":"2017/11/07/linux_oracle/","link":"","permalink":"http://sunjx93.com/2017/11/07/linux_oracle/","excerpt":"由于项目在运行过程中所需的空间越来越大，最终Linux的表分区使用比例达到了100%，导致项目无法正常登录以及无法正常访问数据库，原因主要是表空间过大。在备份了dbf文件后之后，由于操作有误，误删了oracle的一个redo日志，于是不得不重装oracle 因为表空间主要存储的都是用户上传的文件数据，所以必须恢复","text":"由于项目在运行过程中所需的空间越来越大，最终Linux的表分区使用比例达到了100%，导致项目无法正常登录以及无法正常访问数据库，原因主要是表空间过大。在备份了dbf文件后之后，由于操作有误，误删了oracle的一个redo日志，于是不得不重装oracle 因为表空间主要存储的都是用户上传的文件数据，所以必须恢复 ps: 因为服务器上相关的配置文件都配置过一遍，所以不用重新配置 1. 把dbf文件通过恢复工具导入到测试环境在网上找了好多数据库恢复的软件，但都是收费的…QAQ 最后选择一个叫odu的工具，非图形化界面，需要注意的是配置文件的格式需要规范一点，具体的操作步骤可以看： 老熊的博客 再贴一个odu的下载 总之经过一番操作之后终于把数据跑到自己电脑上了，随后我们要进行的是linux在oracle的命令行安装。 2. oracle 静默安装 由于这个项目的运行环境是内网环境，所以一些yum什么的工具都暂时用不了，当时也没有什么时间去鼓捣图形化之类的东西了，就试着用xshell进行了命令行安装。 a. 下载oracle for linux 的zip安装包上传到机器上并解压，要注意文件的权限不能是root，应该是oracle，也就是用作数据库的权限账号 b. 使用oracle用户登录并解压到一个目录下 unzip filenamec. 解压完之后会有一个database目录我们要找到/oracle/database/response下的三个.rsp 文件，复制到/home/oracle里面，并在这里做一些修改。 首先 是db_install.rsp,这里的改动需要仔细，如果配置错误的话就会报错。 静默安装_db-install.rsp 配置 接下来是dbca.rsp和netca.rsp dbca.rspvi dbca.rsp 修改以下内容 GDBNAME = “ora11g” SID = “ora11g” SYSPASSWORD = “oracle11” SYSTEMPASSWORD = “oracle11” netca.rspvi netca.rsp修改以下内容 INSTALL_TYPE=””custom”” 配置完之后进入database目录下，执行脚本1./runInstaller -silent -responseFile /home/oracle/db_install.rsp 如果一切顺利的话，会提示你the setup completed 之类的，而且会提示你运行两个文件，注意: 这两个文件需要用root用户运行。 运行完成后，可能要退回oracle 的主目录刷新一下.bash_profile1source .bash_profile 成功后就可以看到登录信息里有自己的sid了，这个时候就是常规操作： 12345创建数据库 dbca -silent -cloneTemplate -responseFile ./dbca.rsp创建监听 netca /silent /responseFile /home/oracle/netca.rsp开启oracle监听 lsnrctl start 3 创建oracle 实例 安装好oracle 之后是没有oracle实例的，需要自己去建 创建oracle实例（没错我在偷懒） 总之最后很幸运的没有丢数据，我们一定要做好的是备份！备份！备份！","categories":[],"tags":[{"name":"Linux - Oracle","slug":"Linux-Oracle","permalink":"http://sunjx93.com/tags/Linux-Oracle/"}]},{"title":"Quartz实现定时任务","slug":"Quartz","date":"2017-07-07T08:52:09.000Z","updated":"2017-07-17T10:32:09.781Z","comments":true,"path":"2017/07/07/Quartz/","link":"","permalink":"http://sunjx93.com/2017/07/07/Quartz/","excerpt":"Quartz 最近公司项目中用到了定时任务提醒的功能，Timer在功能上已经无法很好的满足业务，来学习一下Quartz","text":"Quartz 最近公司项目中用到了定时任务提醒的功能，Timer在功能上已经无法很好的满足业务，来学习一下Quartz Quartz 的生命周期 Job接口在execute（JobExecation…）{}中编写逻辑 调用器 执行Job时创建的Job实例，调用完成时，job实例会被释放并回收 JobDetail属性 name 任务名称 group 任务组 默认DEFAULT jobclass jobDetailMap 作用是在execute中传递参数，一般为基本数据类型 ...... JobDataMap&amp;TriggerDataMap: 强力的map型参数，由quzrtz封装，同时实现了map接口 关于Quzrtz的Trigger 作为Quartz的触发器来执行JobTrigger的通用属性 Job Key： 获取JobDetail的key值 startTime： 触发器首次触发的时间 endTime： …停止时间 SimpleTrigger&amp; CronTriggerSimpleTrigger： SimpleTrigge有点类似Java中Timer的一个变体，但是个人觉得在逻辑上比Timer要来的简便 CronTrigger： CronTrigger是Quartz的核心，是一种基于日历的作业调度器 重点： cron表达式：用来配置CronTrigger实例 由7个子表达式组成,描述了时间表的详细信息 格式： [秒] [分] [小时] [日] [月] [年] 注意 []之间有空格符 事例 1234567891011121314151617181920JobDetail jobDetail = JobBuilder.newJob(QuartzJob.class) .withIdentity(&quot;myJob&quot;).build();CronTrigger trigger = (CronTrigger) TriggerBuilder .newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .withSchedule( CronScheduleBuilder.cronSchedule(&quot;* * * * * ?&quot;)) .build();// 创建Scheduler实例SchedulerFactory sfact = new StdSchedulerFactory();Scheduler scheduler = sfact.getScheduler();scheduler.start();System.out.println(&quot;scheduled time is :&quot; + sf.format(scheduler.scheduleJob(jobDetail, trigger)));//scheduler执行两秒后挂起Thread.sleep(2000L);//shutdown(true)表示等待所有正在执行的job执行完毕之后，再关闭scheduler//shutdown(false)即shutdown()表示直接关闭schedulerscheduler.shutdown(false);System.out.println(&quot;scheduler is shut down? &quot; + scheduler.isShutdown()); 其中CronScheduleBuilder.cronSchedule(&quot;* * * * * ?&quot;))这句就是Cron表达式的用法 关于Cron表达式的字符含义: 字段 是否必填 允许值 允许的特殊字符 秒 是 0-59 , - * / 分 是 0-59 , - * / 小时 是 0-23 , - * / 日 是 1-31 , - * ? / L W C 月 是 1-12或者JAN-DEC , - * / 周 是 1-7或者SUN-SAT ,- * ? / L C # 年 否 empty,1970-2099 , - * / 特殊字符 含义 , 表示或 的意思 - 至某事某刻，between的关系 * 表示每， / 表示每隔某时间段触发，比如分的写法:0/5 表示每隔5分钟触发，5/20代表每五分钟触发一次，25,45各触发一次 ? 表示无所谓，不关注，无关紧要 # 第的意思，如6#3每月第三周星期五触发，6代表周五 L 代表最后一 的意思 W 表示有效工作日（周一到周五）， L与W可连用，表示某月最后一个工作日 关于周的换算：1代表周日，6代表周五，以此类推类推 如：0 15 10 ? * 6L 2016-2017: 2016-2017年每月最后一周的周五10点15分执行 年可以不填QAQ ###SchedulerFactory 用来工厂模式来创建Schedular StdSchedulerFactory利用.getScheduler();方法初始创建调度器，参数配置可以采用quartz。properties方法 比较Timer1.无法并发执行：Timer不怎么支持并发 2.因为Timer有且仅有一个后台执行的线程，若一旦爆出RunTimeException，则会停止所有的任务执行 瓶颈：a) 对时效性要求较高的多任务并发作业，虽然支持多任务，但是毕竟是串行接口 b) 对复杂任务的调度不足，不支持定时任务 Quartz1.精细控制流程 2.支持若干任务在上面执行 a)调度功能 b) 持久化机制，数据不会丢失 c) 分布&amp;集群功能","categories":[],"tags":[{"name":"Quartz - Timer","slug":"Quartz-Timer","permalink":"http://sunjx93.com/tags/Quartz-Timer/"}]},{"title":"SpringData相关","slug":"sd","date":"2017-05-27T08:52:09.000Z","updated":"2017-05-31T05:53:27.405Z","comments":true,"path":"2017/05/27/sd/","link":"","permalink":"http://sunjx93.com/2017/05/27/sd/","excerpt":"SpringData是原先工作用到了的东西，提供一个一致性的，基于spring的项目，用来访问数据（访问数据库），现在来半预习半复习一下","text":"SpringData是原先工作用到了的东西，提供一个一致性的，基于spring的项目，用来访问数据（访问数据库），现在来半预习半复习一下 特点 可以访问关系型数据库，也可以访问非关系型数据库 目的 减少数据访问层的开发量 其实只需要声明一个持久层的接口 springData 包含的子项目 Spring Data JPA Spring Data MongoDB Spring Data Redis Spring Data Solr (一个全文搜索的东西) 等等….. 1.传统方式访问数据库 jdbc get connection get statement resultSet a)添加依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; b)开发JDBCUtil 工具类获取connection 12345678910111213141516171819/** * 获取connection * @return */public static Connection getConnection() throws Exception &#123; //获取配置文件的方法，db.properties 是设置好的配置文件 InputStream input = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties = new Properties(); properties.load(input); String url = properties.get(&quot;jdbc.url&quot;).toString(); String username = properties.get(&quot;jdbc.username&quot;).toString(); String driverClass = properties.get(&quot;user.driverClass&quot;).toString(); Class.forName(driverClass); Connection conn= DriverManager.getConnection(url, username, &quot;&quot;); return conn;&#125; db.properties,灰色的就是没有使用过的 1234user.driverClass = com.mysql.jdbc.Driveruser.username= rootuser.url=jdbc:mysql:///localhostuser.password = 使用 springData jdbc 模板访问数据库 c) DAO 层开发 真的是好复古好复古的写法，DaoImpl1234567891011121314151617181920212223242526272829303132333435/** * 传说中的经典写法？？？？ * @return */ public List&lt;Student&gt; selectAllStudents() &#123; Connection conn = null; PreparedStatement preparedStatement =null; ResultSet resultSet=null; List&lt;Student&gt; li = new ArrayList&lt;Student&gt;(); String sql = &quot;select id ,name,age from tb_student &quot;; Student student = null; try &#123; conn = JDBCUtil.getConnection(); preparedStatement = conn.prepareStatement(sql); resultSet = preparedStatement.executeQuery(); while(resultSet.next())&#123; //获取结果集中int类型的id对应的value int id = resultSet.getInt(&quot;id&quot;); String name = resultSet.getString(&quot;name&quot;); int age = resultSet.getInt(&quot;age&quot;); student = new Student(); student.setAge(age); student.setId(id); student.setName(name); li.add(student); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(resultSet,preparedStatement,conn); &#125; return li; &#125; 2.Spring模板方式访问数据库—-SpringTemplet 配置xml 12345678&lt;!-- dbcTermplet--&gt; &lt;bean id=&quot;jdbcTemplet&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.drazen.dao.impl.SpringJdbcDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplet&quot;/&gt; &lt;/bean&gt; 然后再dao层调用jdbcTemplet: 1234567891011121314151617181920212223242526 private JdbcTemplate jdbcTemplate; public JdbcTemplate getJdbcTemplate() &#123; return jdbcTemplate;&#125;public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate;&#125; public List&lt;Student&gt; selectAllStudents() &#123; final List&lt;Student&gt; li = new ArrayList&lt;Student&gt;(); String sql = &quot;select id ,name,age from tb_student &quot;; jdbcTemplate.query(sql, new RowCallbackHandler() &#123; public void processRow(ResultSet resultSet) throws SQLException &#123; int id = resultSet.getInt(&quot;id&quot;); String name = resultSet.getString(&quot;name&quot;); int age = resultSet.getInt(&quot;age&quot;); Student student = new Student(); student.setAge(age); student.setId(id); student.setName(name); li.add(student); &#125; &#125;); return li; &#125; 其实这些方式代码量很多，且很重复，人力成本比较高 SpringData 方式1.开发环境：maven 依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-jpa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.10.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-entitymanager --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;5.1.0.Final&lt;/version&gt; &lt;/dependency&gt; 依赖下载完成后，就要配置bean.xml文件 在bean.xml中配置EntityManagerFactoryEntityManagerFactory是SpringData的核心之一 123456789101112131415161718&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;jpaVendorAdapter&quot;&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;com.drazen&quot;/&gt; &lt;property name=&quot;jpaProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.ejb.naming_strategy&quot;&gt;org.hibernate.cfg.ImprovedNamingStrategy&lt;/prop&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/prop&gt;&lt;!--hibernate方言--&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;&lt;!--显示sql--&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;&lt;!--格式化sql--&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;&lt;!--如果没有对应表的话根据实体类生成表--&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 然后，定义Dao层类型的接口，注意，要实现SpringData功能，首先应该extendsorg.springframework.data.repository.Repository接口或者使用@RepositoryDefinition(domainClass = Employee.class, idClass = Integer.class)注解。其中的domainClass，idClass属性是对应表的实体类与id主键。 Repository类的定义：123public interface Repository&lt;T, ID extends Serializable&gt; &#123;&#125; 1）Repository是一个空接口，标记接口没有包含方法声明的接口,其实有点像Serializable接口 2）如果我们定义的接口EmployeeRepository extends Repository 如果我们自己的接口没有extends Repository，运行时会报错：org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type ‘com.imooc.repository.EmployeeRepository’ available 3) 添加注解能到达到不用extends Repository的功能@RepositoryDefinition(domainClass = Employee.class, idClass = Integer.class) SpringData可以实现通过方法命名规范来自动生成sql进行查询，也就是说，没有方法体 下面是方法名称的命名规范。 要注意：对于按照方法命名规则来使用的话，有弊端： 方法名会比较长： 约定大于配置 对于一些复杂的查询，是很难实现 @Query是一个更好的使用定制sql的工具注解，我通常把它理解为Mybatis中的类似@Select（）酱紫的,而且，它支持命名参数以及索引参数的使用： 就是?这种参数参数插入 支持本地查询123456789101112131415161718192021@Query(&quot;select o from Employee o where id=(select max(id) from Employee t1)&quot;) public Employee getEmployeeByMaxId(); @Query(&quot;select o from Employee o where o.name=?1 and o.age=?2&quot;) public List&lt;Employee&gt; queryParams1(String name, Integer age); @Query(&quot;select o from Employee o where o.name=:name and o.age=:age&quot;) public List&lt;Employee&gt; queryParams2(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age); @Query(&quot;select o from Employee o where o.name like %?1%&quot;) public List&lt;Employee&gt; queryLike1(String name); @Query(&quot;select o from Employee o where o.name like %:name%&quot;) public List&lt;Employee&gt; queryLike2(@Param(&quot;name&quot;) String name); @Query(nativeQuery = true, value = &quot;select count(1) from employee&quot;) public long getCount(); @Modifying @Query(&quot;update Employee o set o.age = :age where o.id = :id&quot;) public void update(@Param(&quot;id&quot;) Integer id, @Param(&quot;age&quot;) Integer age); 关于SPringData中事物 在写操作中需要事物的支持 @Modifying–允许修改 事物在SpringData中的使用 事务在Spring data中的使用： 1）事务一般是在Service层 2）@Query、 @Modifying、@Transactional的综合使用 使用： 在service层中新建service类，并调用update方法： 123456789101112131415161718192021package com.drazen.service;import com.drazen.repository.EmployeeRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import javax.transaction.Transactional;@Servicepublic class EmployeeService &#123; @Autowired private EmployeeRepository employeeRepository;// 手工加入事物注解，并在spring开启自动扫描 @Transactional public void update(Integer id, Integer age) &#123; employeeRepository.update(id, age); &#125;&#125; 关于SpringData JPA1) CrudRepository接口 这个接口其实就是针对实体进行的机械化写操作，简单粗暴快方法有这些： 12345678910111213141516171819202122//保存一个实体&lt;S extends T&gt; S save(S var1);//保存多个实体&lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; var1);//查找一个实体T findOne(ID var1);//查看某个实体记录是否存在boolean exists(ID var1);//查询所有Iterable&lt;T&gt; findAll();//根据id组查询所有结果Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; var1);//数据字段数量long count();//删除单个void delete(ID var1);//根据实体删除单个void delete(T var1);//删除一组void delete(Iterable&lt;? extends T&gt; var1);//删除所有void deleteAll(); 2)PagingAndSortingRepository 接口支持分页，排序 创建继承了PagingAndSortingRepository的interface12public interface PageRep extends PagingAndSortingRepository&lt;Employee,Integer&gt; &#123;&#125; 1234 // 返回所有实体 Iterable&lt;T&gt; findAll(Sort var1);//返回page对象 Page&lt;T&gt; findAll(Pageable var1); 使用PAGE 构建分页 1234567891011121314151617 @Autowired private PageRep pageRep; public void getPage()&#123; //import org.springframework.data.domain.PageRequest; Pageable pageable = new PageRequest(0,5); Page&lt;Employee&gt; page = pageRep.findAll(pageable);//总页数 System.out.println(page.getTotalPages());// 总记录数 System.out.println(page.getTotalElements());// 当前第几页 System.out.println(page.getNumber());// 当前页面的集合 System.out.println(page.getContent());// 当前页面的记录数 System.out.println(page.getNumberOfElements()); &#125; PageRep 是一个继承了PagingAndSortingRepository的初始interface Pageable 是来自org.springframework.data.domain.PageRequest的类 其实page.getContent()获取到的是List 排序123456789101112131415161718192021 public void getSort()&#123;// import org.springframework.data.domain.Sort.Order;// 进构造器的参数是升序或者降序，类似于order by id desc Sort.Order order = new Sort.Order(Sort.Direction.DESC,&quot;id&quot;);// import org.springframework.data.domain.Sort; Sort sort = new Sort(order);// 将构建好的sort传入PageRequest Pageable pageable = new PageRequest(0,5,sort); Page&lt;Employee&gt; page = pageRep.findAll(pageable); //总页数 System.out.println(page.getTotalPages());// 总记录数 System.out.println(page.getTotalElements());// 当前第几页 System.out.println(page.getNumber());// 当前页面的集合 System.out.println(page.getContent());// 当前页面的记录数 System.out.println(page.getNumberOfElements()); &#125; 3) JpaSpecificationExecutor 接口 其实我觉得这个方法可能还不如直接写sql，但是好像可以对原生sql有很好的支持 Specification封装了JPA Critical 的查询条件 org.springframework.data.jpa.repository目录下 新建接口继承JpaSpecificationExecutor：12public interface JpaSpecificationRepo extends JpaSpecificationExecutor&lt;Employee&gt; &#123;&#125; 组合功能，如分页+排序+查询条件 12345678910111213141516171819202122 public void testNewInterface()&#123;// 假如查询条件设定为age&gt;50 Sort.Order order = new Sort.Order(Sort.Direction.DESC,&quot;id&quot;); Sort sort = new Sort(order);// import org.springframework.data.jpa.domain.Specification; Specification&lt;Employee&gt; specification = new Specification&lt;Employee&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Employee&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) &#123; Path path = root.get(&quot;age&quot;); /*criteriaBuilder: 构建 * root：实体 * criteriaQuery：查询条件 * * */ return criteriaBuilder.gt(path,50); &#125; &#125;; Pageable pageable = new PageRequest(0,5,sort); Page&lt;Employee&gt; page = pageRep.findAll(specification,pageable); &#125; 总结 SpringData也支持非关系型数据库 总的来说，springdata是一个可以提高开发效率的spring的工具集","categories":[],"tags":[{"name":"SpringData","slug":"SpringData","permalink":"http://sunjx93.com/tags/SpringData/"},{"name":"Java","slug":"Java","permalink":"http://sunjx93.com/tags/Java/"}]},{"title":"Jquery 的一些林林总总","slug":"jquery_log1","date":"2017-05-10T08:52:09.000Z","updated":"2017-05-27T08:16:23.245Z","comments":true,"path":"2017/05/10/jquery_log1/","link":"","permalink":"http://sunjx93.com/2017/05/10/jquery_log1/","excerpt":"Jquery 的一些林林总总 最近看了一本《精妙绝伦JQuery》，里面讲的比较细致，自己都快没耐心啃完了，记下来了一些自己能用到的东西，希望以后可以有所帮助","text":"Jquery 的一些林林总总 最近看了一本《精妙绝伦JQuery》，里面讲的比较细致，自己都快没耐心啃完了，记下来了一些自己能用到的东西，希望以后可以有所帮助 首先 - - 最近面试的时候问到的： 123$(document).ready 与JavaScript里onload方法的区别：$(document).ready(function()&#123;&#125;) 代表的是在DOM加载之前完成代码内加载onload 事件会在页面或图像加载完成后立即发生。 这是jQuery的一些常用方法 1234567891011121314151. .load() 预加载图片2. .ready() 事件监测DOM是否完全加载3. .unload() 在离开页面时或用户单机一个新连接是触发4. .resize() 改变浏览器大小时触发5. .scroll() 用户滚动窗口时触发6. .error() 当http请求遇到错误是触发 可以用来显示备用图片，也就是 网页上的图挂了之后，可以用别的图替代图挂了- - 表达不能23337. .bind() 绑定事件函数8. .live() 提供一个灵活的捕获事件的方式 .live(event type,event handler);9. .delegate() 三个参数：1.选择器 2.事件类型 3.响应函数 捕获鼠标事件123456789click 单击鼠标并释放dbclick 双击触发mousedown 鼠标被按下触发mouseup 鼠标松开后触发mouseenter 鼠标进入某易元素区域时触发mouseleave ..离开时触发mousemove 鼠标在区域内移动时触发mouseout 离开该区域及父元素时触发mouseover 鼠标进入某一元素及父元素时触发 捕获表单事件 123456789change() 表单值改变时触发focus() 敲TAB键触发focusin() 元素或子元素得到焦点时触发focusout() 元素或子元素失去焦点时触发blur() 文本域/文本框失去焦点时触发select() 元素内文本被选中时触发submit() 表单提交时触发reset() 重置 关于网站特效1234567show()hide()toggle() 根据当前状态显示/隐藏 切换状态slideDown() 以向下滑动展开的方式显示元素fadeIn() 元素以淡入的方式显示fadeout() 元素以淡入淡出的方式消失fadeTo() 淡入淡出至某个透明度 关于cookie（这可是他娘的重点）1234567891.如何种cookie function startCookie()&#123; var expirDate = new Date(); expirDate.setDate(expirDate.getDate+30); cookie过期时间 document.cookie = &quot;name=hideCookie;expires=&quot;+expirDate.toUTCString &#125; (可以使用jQuery的cookie插件拿到具体cookie) 注：当没有指明 cookie有效时间时，所创建的cookie有效期默认到用户关闭浏览器为止，所以被称为 “会话cookie（session cookie）”。 1234567$.cookie(&apos;cookName&apos;)$.cookie(&apos;key&apos;,&apos;value&apos;)$.cookie(&apos;key&apos;,&apos;value&apos;,&#123; expires: 7 &#125;);//意思是创建一个7天有效期的cookie$.cookie(&apos;key&apos;,&apos;value&apos;,&#123; expires: 7,path:&apos;/&apos;&#125;);//意思是创建一个7天有效期的cookie,且存储路径为/ 读取cookie：1234567$.cookie(&apos;the_cookie&apos;); // cookie存在 =&gt; &apos;the_value&apos;$.cookie(&apos;not_existing&apos;); // cookie不存在 =&gt; null5.删除cookie，通过传递null作为cookie的值即可：$.cookie(&apos;the_cookie&apos;, null); Ajax 传说中的，标志着人类互联网历史的一大步，就连名字也很后现代化的Ajax Ajax指在不需要刷新页面的情况下，允许客户端应用程序传递数据给服务器并获取数据的一组模式和技术 123456789101.$(selector).load(URL,回调函数&#123; &#125;) $(&apos;#content&apos;).load(&apos;Class5.html&apos;,function(responseText,textStatus,XMLHttpRequest)&#123; //检查不同的响应码 if(XMLHttpRequest.status == 404||XMLHttpRequest.status == 500)&#123; $(&apos;#content&apos;).html(&apos;There has been an error,please try angin later&apos;); &#125; &#125;); 关于响应码 响应码 对应解释 200 成功 301 永久跳转 302 临时跳转 400 错误请求 401 未授权 403 禁止访问 404 未找到 500 服务器错误 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 2.载入过程的动画 在.load() 之前 $(&apos;#content&apos;).html(&apos;&lt;img...&gt;&apos;); 3.载入部分内容 $(&apos;#content&apos;).load(URL class or id or tag name ) 如： $(&apos;#content&apos;).load(&apos;class1.html.specal&apos;)------意味着该html里只有class=&quot;specal&quot; 的标签才可以被加载 4.get/post 提交表单 Get:服务器在URL中拾取键值对 Post: $.ajax(&#123; type:&apos;post&apos;, url:url, data:data, success:success, dataType:dataType &#125;); post 请求提交数据： 两种方式：标准\\快捷 标准：$.post(url,[data],[success],dataType); 快捷：$.ajax(&#123; url:url, data:data, success:success, dataType:dataType &#125;); 5.操作XML数据 a.XML是跨平台的标准 如何得到xml并解读，展示在html上 $.ajax(&#123; type:&apos;GET&apos;, url:&quot;xx.xml&quot;, dataType:&quot;XML&quot;, success:parseXML ---回调函数 &#125;);生成html function parseXML(xml)&#123; $(xml).find(&quot;Book&quot;).each(function()&#123; var author = $(this).attr(&apos;author&apos;); $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(&apos;&lt;b&gt;Author&lt;/b&gt;:&apos;+author).appendTo(&apos;#books&apos;);; &#125;; &#125;6.操作JSon数据 json是JavaScript的表示法，它允许以键值对的形式创建自己的数据结构 a.获取json并生成html $.getJSON();或$.ajax function processJson(data)&#123; $.each(data.books,function(i,item)); &#125; 接下来要做的跟xml类似，你只需要获取item中的键值来生成html","categories":[],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://sunjx93.com/tags/Jquery/"}]},{"title":"终于搞定了","slug":"终于搞定了","date":"2017-04-18T08:52:09.000Z","updated":"2017-05-27T08:16:30.750Z","comments":true,"path":"2017/04/18/终于搞定了/","link":"","permalink":"http://sunjx93.com/2017/04/18/终于搞定了/","excerpt":"作为小白中的小白，在升级之路上偶然看到好多大牛自己架设的博客，非常羡慕，在尝试了好久之后，终于初步搞定，微不足道的一大步，记录一下 ：）","text":"作为小白中的小白，在升级之路上偶然看到好多大牛自己架设的博客，非常羡慕，在尝试了好久之后，终于初步搞定，微不足道的一大步，记录一下 ：） 当初是看到这位的博客Giraffe’s Home然后也想自己弄一个。 来记录一下当时我整这破玩意的步骤： 首先首先你需要安装Git 和Node js Git 官网NodeJs 中文网 其次，你需要一个GItHub的账号然后，你就可以来安装hexo了 首先打开的是Git bash：对呀你得用到刚刚安的东西！ npm install -g hexo 初始化然后，执行init命令初始化hexo,命令：（你可以选择这个目录在电脑里的位置） hexo init blog blog就是你的博客根目录，所有的操作都在里面进行。以后提交啥的都要先到这个目录再提交。 hexo generate（hexo g）生成页面 如果你生成页面的时候报错，大概是hexo版本的问题，你需要先执行： npm install hexo-deployer-git –save 启动本地服务 hexo server 然后在 http://localhost4000这里就可以看到本地的博客了。 如果你想发布到网站上你需要登录GitHub账号，然后新建一个仓库（Repository），命名规则是你的GitHub用户名.github.io比如我的：Drazen08.github.io 然后：打开你本地blog文件夹，里面有一个_config.yml文件，这个需要做一些小改动： 需要注意的是！所有 ：冒号后面都要跟一个空格，要不然会报错，这里曾经困扰我好久！！！！123456title: Drazen -- 标题subtitle: the stack of it nerds -- 大概是类似座右铭之类的东西description: start from zeroauthor: JFuncnoviclanguage: zh-Hanstimezone: AsiaShanghai 需要注意的是language 和timezone ，语言和时区。 这里： 1theme: huno huno是我下载的主题，放在{目录}/theme/huno下。 最重要的是1234deploy type: git repo: git@github.comDrazen08Drazen08.github.io.git branch: master repo的地址是ssl形式的，其实好像不用这么麻烦，或许是我被墙了。。 最后执行hexo deploy 在浏览器中输入 你自己的.github.io 就可以访问了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate hexo deploy 一些常用命令：hexo newpostName #新建文章 hexo new pagepageName #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，ctrl + c关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 对了，当时好像我配置了一个ssh码关联到github上，忘记了。","categories":[],"tags":[{"name":"Hexo_Github","slug":"Hexo-Github","permalink":"http://sunjx93.com/tags/Hexo-Github/"}]}]}