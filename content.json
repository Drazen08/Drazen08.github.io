{"meta":{"title":"Drazen","subtitle":"the stack of it nerds","description":"start from zero","author":"JFuncnovic","url":"http://sunjx93.com"},"pages":[],"posts":[{"title":"SpringData相关","slug":"sd","date":"2017-05-27T08:52:09.000Z","updated":"2017-05-31T05:42:24.791Z","comments":true,"path":"2017/05/27/sd/","link":"","permalink":"http://sunjx93.com/2017/05/27/sd/","excerpt":"SpringData是原先工作用到了的东西，提供一个一致性的，基于spring的项目，用来访问数据（访问数据库），现在来半预习半复习一下","text":"SpringData是原先工作用到了的东西，提供一个一致性的，基于spring的项目，用来访问数据（访问数据库），现在来半预习半复习一下 特点 可以访问关系型数据库，也可以访问非关系型数据库 目的 减少数据访问层的开发量 其实只需要声明一个持久层的接口 springData 包含的子项目 Spring Data JPA Spring Data MongoDB Spring Data Redis Spring Data Solr (一个全文搜索的东西) 等等….. 1.传统方式访问数据库 jdbc get connection get statement resultSet a)添加依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; b)开发JDBCUtil 工具类获取connection 12345678910111213141516171819/** * 获取connection * @return */public static Connection getConnection() throws Exception &#123; //获取配置文件的方法，db.properties 是设置好的配置文件 InputStream input = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties = new Properties(); properties.load(input); String url = properties.get(&quot;jdbc.url&quot;).toString(); String username = properties.get(&quot;jdbc.username&quot;).toString(); String driverClass = properties.get(&quot;user.driverClass&quot;).toString(); Class.forName(driverClass); Connection conn= DriverManager.getConnection(url, username, &quot;&quot;); return conn;&#125; db.properties,灰色的就是没有使用过的 1234user.driverClass = com.mysql.jdbc.Driveruser.username= rootuser.url=jdbc:mysql:///localhostuser.password = 使用 springData jdbc 模板访问数据库 c) DAO 层开发 真的是好复古好复古的写法，DaoImpl1234567891011121314151617181920212223242526272829303132333435/** * 传说中的经典写法？？？？ * @return */ public List&lt;Student&gt; selectAllStudents() &#123; Connection conn = null; PreparedStatement preparedStatement =null; ResultSet resultSet=null; List&lt;Student&gt; li = new ArrayList&lt;Student&gt;(); String sql = &quot;select id ,name,age from tb_student &quot;; Student student = null; try &#123; conn = JDBCUtil.getConnection(); preparedStatement = conn.prepareStatement(sql); resultSet = preparedStatement.executeQuery(); while(resultSet.next())&#123; //获取结果集中int类型的id对应的value int id = resultSet.getInt(&quot;id&quot;); String name = resultSet.getString(&quot;name&quot;); int age = resultSet.getInt(&quot;age&quot;); student = new Student(); student.setAge(age); student.setId(id); student.setName(name); li.add(student); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(resultSet,preparedStatement,conn); &#125; return li; &#125; 2.Spring模板方式访问数据库—-SpringTemplet 配置xml 12345678&lt;!-- dbcTermplet--&gt; &lt;bean id=&quot;jdbcTemplet&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.drazen.dao.impl.SpringJdbcDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplet&quot;/&gt; &lt;/bean&gt; 然后再dao层调用jdbcTemplet: 1234567891011121314151617181920212223242526 private JdbcTemplate jdbcTemplate; public JdbcTemplate getJdbcTemplate() &#123; return jdbcTemplate;&#125;public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate;&#125; public List&lt;Student&gt; selectAllStudents() &#123; final List&lt;Student&gt; li = new ArrayList&lt;Student&gt;(); String sql = &quot;select id ,name,age from tb_student &quot;; jdbcTemplate.query(sql, new RowCallbackHandler() &#123; public void processRow(ResultSet resultSet) throws SQLException &#123; int id = resultSet.getInt(&quot;id&quot;); String name = resultSet.getString(&quot;name&quot;); int age = resultSet.getInt(&quot;age&quot;); Student student = new Student(); student.setAge(age); student.setId(id); student.setName(name); li.add(student); &#125; &#125;); return li; &#125; 其实这些方式代码量很多，且很重复，人力成本比较高 SpringData 方式1.开发环境：maven 依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-jpa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.10.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-entitymanager --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;5.1.0.Final&lt;/version&gt; &lt;/dependency&gt; 依赖下载完成后，就要配置bean.xml文件 在bean.xml中配置EntityManagerFactoryEntityManagerFactory是SpringData的核心之一 123456789101112131415161718&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;jpaVendorAdapter&quot;&gt; &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;com.drazen&quot;/&gt; &lt;property name=&quot;jpaProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.ejb.naming_strategy&quot;&gt;org.hibernate.cfg.ImprovedNamingStrategy&lt;/prop&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/prop&gt;&lt;!--hibernate方言--&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;&lt;!--显示sql--&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;&lt;!--格式化sql--&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;&lt;!--如果没有对应表的话根据实体类生成表--&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 然后，定义Dao层类型的接口，注意，要实现SpringData功能，首先应该extendsorg.springframework.data.repository.Repository接口或者使用@RepositoryDefinition(domainClass = Employee.class, idClass = Integer.class)注解。其中的domainClass，idClass属性是对应表的实体类与id主键。 Repository类的定义：123public interface Repository&lt;T, ID extends Serializable&gt; &#123;&#125; 1）Repository是一个空接口，标记接口没有包含方法声明的接口,其实有点像Serializable接口 2）如果我们定义的接口EmployeeRepository extends Repository 如果我们自己的接口没有extends Repository，运行时会报错：org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type ‘com.imooc.repository.EmployeeRepository’ available 3) 添加注解能到达到不用extends Repository的功能@RepositoryDefinition(domainClass = Employee.class, idClass = Integer.class) SpringData可以实现通过方法命名规范来自动生成sql进行查询，也就是说，没有方法体 下面是方法名称的命名规范。 要注意：对于按照方法命名规则来使用的话，有弊端： 方法名会比较长： 约定大于配置 对于一些复杂的查询，是很难实现 @Query是一个更好的使用定制sql的工具注解，我通常把它理解为Mybatis中的类似@Select（）酱紫的,而且，它支持命名参数以及索引参数的使用： 就是?这种参数参数插入 支持本地查询123456789101112131415161718192021@Query(&quot;select o from Employee o where id=(select max(id) from Employee t1)&quot;) public Employee getEmployeeByMaxId(); @Query(&quot;select o from Employee o where o.name=?1 and o.age=?2&quot;) public List&lt;Employee&gt; queryParams1(String name, Integer age); @Query(&quot;select o from Employee o where o.name=:name and o.age=:age&quot;) public List&lt;Employee&gt; queryParams2(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;) Integer age); @Query(&quot;select o from Employee o where o.name like %?1%&quot;) public List&lt;Employee&gt; queryLike1(String name); @Query(&quot;select o from Employee o where o.name like %:name%&quot;) public List&lt;Employee&gt; queryLike2(@Param(&quot;name&quot;) String name); @Query(nativeQuery = true, value = &quot;select count(1) from employee&quot;) public long getCount(); @Modifying @Query(&quot;update Employee o set o.age = :age where o.id = :id&quot;) public void update(@Param(&quot;id&quot;) Integer id, @Param(&quot;age&quot;) Integer age); 关于SPringData中事物 在写操作中需要事物的支持 @Modifying–允许修改 事物在SpringData中的使用 事务在Spring data中的使用： 1）事务一般是在Service层 2）@Query、 @Modifying、@Transactional的综合使用 使用： 在service层中新建service类，并调用update方法： 123456789101112131415161718192021package com.drazen.service;import com.drazen.repository.EmployeeRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import javax.transaction.Transactional;@Servicepublic class EmployeeService &#123; @Autowired private EmployeeRepository employeeRepository;// 手工加入事物注解，并在spring开启自动扫描 @Transactional public void update(Integer id, Integer age) &#123; employeeRepository.update(id, age); &#125;&#125; 关于SpringData JPA1) CrudRepository接口 这个接口其实就是针对实体进行的机械化写操作，简单粗暴快方法有这些： 12345678910111213141516171819202122//保存一个实体&lt;S extends T&gt; S save(S var1);//保存多个实体&lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; var1);//查找一个实体T findOne(ID var1);//查看某个实体记录是否存在boolean exists(ID var1);//查询所有Iterable&lt;T&gt; findAll();//根据id组查询所有结果Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; var1);//数据字段数量long count();//删除单个void delete(ID var1);//根据实体删除单个void delete(T var1);//删除一组void delete(Iterable&lt;? extends T&gt; var1);//删除所有void deleteAll(); 2)PagingAndSortingRepository 接口支持分页，排序 创建继承了PagingAndSortingRepository的interface12public interface PageRep extends PagingAndSortingRepository&lt;Employee,Integer&gt; &#123;&#125; 1234 // 返回所有实体 Iterable&lt;T&gt; findAll(Sort var1);//返回page对象 Page&lt;T&gt; findAll(Pageable var1); 使用PAGE 构建分页 1234567891011121314151617 @Autowired private PageRep pageRep; public void getPage()&#123; //import org.springframework.data.domain.PageRequest; Pageable pageable = new PageRequest(0,5); Page&lt;Employee&gt; page = pageRep.findAll(pageable);//总页数 System.out.println(page.getTotalPages());// 总记录数 System.out.println(page.getTotalElements());// 当前第几页 System.out.println(page.getNumber());// 当前页面的集合 System.out.println(page.getContent());// 当前页面的记录数 System.out.println(page.getNumberOfElements()); &#125; PageRep 是一个继承了PagingAndSortingRepository的初始interface Pageable 是来自org.springframework.data.domain.PageRequest的类 其实page.getContent()获取到的是List 排序123456789101112131415161718192021 public void getSort()&#123;// import org.springframework.data.domain.Sort.Order;// 进构造器的参数是升序或者降序，类似于order by id desc Sort.Order order = new Sort.Order(Sort.Direction.DESC,&quot;id&quot;);// import org.springframework.data.domain.Sort; Sort sort = new Sort(order);// 将构建好的sort传入PageRequest Pageable pageable = new PageRequest(0,5,sort); Page&lt;Employee&gt; page = pageRep.findAll(pageable); //总页数 System.out.println(page.getTotalPages());// 总记录数 System.out.println(page.getTotalElements());// 当前第几页 System.out.println(page.getNumber());// 当前页面的集合 System.out.println(page.getContent());// 当前页面的记录数 System.out.println(page.getNumberOfElements()); &#125; 3) JpaSpecificationExecutor 接口 其实我觉得这个方法可能还不如直接写sql，但是好像可以对原生sql有很好的支持 Specification封装了JPA Critical 的查询条件 org.springframework.data.jpa.repository目录下 新建接口继承JpaSpecificationExecutor：12public interface JpaSpecificationRepo extends JpaSpecificationExecutor&lt;Employee&gt; &#123;&#125; 组合功能，如分页+排序+查询条件 12345678910111213141516171819202122 public void testNewInterface()&#123;// 假如查询条件设定为age&gt;50 Sort.Order order = new Sort.Order(Sort.Direction.DESC,&quot;id&quot;); Sort sort = new Sort(order);// import org.springframework.data.jpa.domain.Specification; Specification&lt;Employee&gt; specification = new Specification&lt;Employee&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Employee&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) &#123; Path path = root.get(&quot;age&quot;); /*criteriaBuilder: 构建 * root：实体 * criteriaQuery：查询条件 * * */ return criteriaBuilder.gt(path,50); &#125; &#125;; Pageable pageable = new PageRequest(0,5,sort); Page&lt;Employee&gt; page = pageRep.findAll(specification,pageable); &#125; 总结 SpringData也支持非关系型数据库 总的来说，springdata是一个可以提高开发效率的spring的工具集","categories":[],"tags":[{"name":"SpringData,Java","slug":"SpringData-Java","permalink":"http://sunjx93.com/tags/SpringData-Java/"}]},{"title":"Jquery 的一些林林总总","slug":"jquery_log1","date":"2017-05-10T08:52:09.000Z","updated":"2017-05-27T08:16:23.245Z","comments":true,"path":"2017/05/10/jquery_log1/","link":"","permalink":"http://sunjx93.com/2017/05/10/jquery_log1/","excerpt":"Jquery 的一些林林总总 最近看了一本《精妙绝伦JQuery》，里面讲的比较细致，自己都快没耐心啃完了，记下来了一些自己能用到的东西，希望以后可以有所帮助","text":"Jquery 的一些林林总总 最近看了一本《精妙绝伦JQuery》，里面讲的比较细致，自己都快没耐心啃完了，记下来了一些自己能用到的东西，希望以后可以有所帮助 首先 - - 最近面试的时候问到的： 123$(document).ready 与JavaScript里onload方法的区别：$(document).ready(function()&#123;&#125;) 代表的是在DOM加载之前完成代码内加载onload 事件会在页面或图像加载完成后立即发生。 这是jQuery的一些常用方法 1234567891011121314151. .load() 预加载图片2. .ready() 事件监测DOM是否完全加载3. .unload() 在离开页面时或用户单机一个新连接是触发4. .resize() 改变浏览器大小时触发5. .scroll() 用户滚动窗口时触发6. .error() 当http请求遇到错误是触发 可以用来显示备用图片，也就是 网页上的图挂了之后，可以用别的图替代图挂了- - 表达不能23337. .bind() 绑定事件函数8. .live() 提供一个灵活的捕获事件的方式 .live(event type,event handler);9. .delegate() 三个参数：1.选择器 2.事件类型 3.响应函数 捕获鼠标事件123456789click 单击鼠标并释放dbclick 双击触发mousedown 鼠标被按下触发mouseup 鼠标松开后触发mouseenter 鼠标进入某易元素区域时触发mouseleave ..离开时触发mousemove 鼠标在区域内移动时触发mouseout 离开该区域及父元素时触发mouseover 鼠标进入某一元素及父元素时触发 捕获表单事件 123456789change() 表单值改变时触发focus() 敲TAB键触发focusin() 元素或子元素得到焦点时触发focusout() 元素或子元素失去焦点时触发blur() 文本域/文本框失去焦点时触发select() 元素内文本被选中时触发submit() 表单提交时触发reset() 重置 关于网站特效1234567show()hide()toggle() 根据当前状态显示/隐藏 切换状态slideDown() 以向下滑动展开的方式显示元素fadeIn() 元素以淡入的方式显示fadeout() 元素以淡入淡出的方式消失fadeTo() 淡入淡出至某个透明度 关于cookie（这可是他娘的重点）1234567891.如何种cookie function startCookie()&#123; var expirDate = new Date(); expirDate.setDate(expirDate.getDate+30); cookie过期时间 document.cookie = &quot;name=hideCookie;expires=&quot;+expirDate.toUTCString &#125; (可以使用jQuery的cookie插件拿到具体cookie) 注：当没有指明 cookie有效时间时，所创建的cookie有效期默认到用户关闭浏览器为止，所以被称为 “会话cookie（session cookie）”。 1234567$.cookie(&apos;cookName&apos;)$.cookie(&apos;key&apos;,&apos;value&apos;)$.cookie(&apos;key&apos;,&apos;value&apos;,&#123; expires: 7 &#125;);//意思是创建一个7天有效期的cookie$.cookie(&apos;key&apos;,&apos;value&apos;,&#123; expires: 7,path:&apos;/&apos;&#125;);//意思是创建一个7天有效期的cookie,且存储路径为/ 读取cookie：1234567$.cookie(&apos;the_cookie&apos;); // cookie存在 =&gt; &apos;the_value&apos;$.cookie(&apos;not_existing&apos;); // cookie不存在 =&gt; null5.删除cookie，通过传递null作为cookie的值即可：$.cookie(&apos;the_cookie&apos;, null); Ajax 传说中的，标志着人类互联网历史的一大步，就连名字也很后现代化的Ajax Ajax指在不需要刷新页面的情况下，允许客户端应用程序传递数据给服务器并获取数据的一组模式和技术 123456789101.$(selector).load(URL,回调函数&#123; &#125;) $(&apos;#content&apos;).load(&apos;Class5.html&apos;,function(responseText,textStatus,XMLHttpRequest)&#123; //检查不同的响应码 if(XMLHttpRequest.status == 404||XMLHttpRequest.status == 500)&#123; $(&apos;#content&apos;).html(&apos;There has been an error,please try angin later&apos;); &#125; &#125;); 关于响应码 响应码 对应解释 200 成功 301 永久跳转 302 临时跳转 400 错误请求 401 未授权 403 禁止访问 404 未找到 500 服务器错误 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 2.载入过程的动画 在.load() 之前 $(&apos;#content&apos;).html(&apos;&lt;img...&gt;&apos;); 3.载入部分内容 $(&apos;#content&apos;).load(URL class or id or tag name ) 如： $(&apos;#content&apos;).load(&apos;class1.html.specal&apos;)------意味着该html里只有class=&quot;specal&quot; 的标签才可以被加载 4.get/post 提交表单 Get:服务器在URL中拾取键值对 Post: $.ajax(&#123; type:&apos;post&apos;, url:url, data:data, success:success, dataType:dataType &#125;); post 请求提交数据： 两种方式：标准\\快捷 标准：$.post(url,[data],[success],dataType); 快捷：$.ajax(&#123; url:url, data:data, success:success, dataType:dataType &#125;); 5.操作XML数据 a.XML是跨平台的标准 如何得到xml并解读，展示在html上 $.ajax(&#123; type:&apos;GET&apos;, url:&quot;xx.xml&quot;, dataType:&quot;XML&quot;, success:parseXML ---回调函数 &#125;);生成html function parseXML(xml)&#123; $(xml).find(&quot;Book&quot;).each(function()&#123; var author = $(this).attr(&apos;author&apos;); $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(&apos;&lt;b&gt;Author&lt;/b&gt;:&apos;+author).appendTo(&apos;#books&apos;);; &#125;; &#125;6.操作JSon数据 json是JavaScript的表示法，它允许以键值对的形式创建自己的数据结构 a.获取json并生成html $.getJSON();或$.ajax function processJson(data)&#123; $.each(data.books,function(i,item)); &#125; 接下来要做的跟xml类似，你只需要获取item中的键值来生成html","categories":[],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://sunjx93.com/tags/Jquery/"}]},{"title":"终于搞定了","slug":"终于搞定了","date":"2017-04-18T08:52:09.000Z","updated":"2017-05-27T08:16:30.750Z","comments":true,"path":"2017/04/18/终于搞定了/","link":"","permalink":"http://sunjx93.com/2017/04/18/终于搞定了/","excerpt":"作为小白中的小白，在升级之路上偶然看到好多大牛自己架设的博客，非常羡慕，在尝试了好久之后，终于初步搞定，微不足道的一大步，记录一下 ：）","text":"作为小白中的小白，在升级之路上偶然看到好多大牛自己架设的博客，非常羡慕，在尝试了好久之后，终于初步搞定，微不足道的一大步，记录一下 ：） 当初是看到这位的博客Giraffe’s Home然后也想自己弄一个。 来记录一下当时我整这破玩意的步骤： 首先首先你需要安装Git 和Node js Git 官网NodeJs 中文网 其次，你需要一个GItHub的账号然后，你就可以来安装hexo了 首先打开的是Git bash：对呀你得用到刚刚安的东西！ npm install -g hexo 初始化然后，执行init命令初始化hexo,命令：（你可以选择这个目录在电脑里的位置） hexo init blog blog就是你的博客根目录，所有的操作都在里面进行。以后提交啥的都要先到这个目录再提交。 hexo generate（hexo g）生成页面 如果你生成页面的时候报错，大概是hexo版本的问题，你需要先执行： npm install hexo-deployer-git –save 启动本地服务 hexo server 然后在 http://localhost4000这里就可以看到本地的博客了。 如果你想发布到网站上你需要登录GitHub账号，然后新建一个仓库（Repository），命名规则是你的GitHub用户名.github.io比如我的：Drazen08.github.io 然后：打开你本地blog文件夹，里面有一个_config.yml文件，这个需要做一些小改动： 需要注意的是！所有 ：冒号后面都要跟一个空格，要不然会报错，这里曾经困扰我好久！！！！123456title: Drazen -- 标题subtitle: the stack of it nerds -- 大概是类似座右铭之类的东西description: start from zeroauthor: JFuncnoviclanguage: zh-Hanstimezone: AsiaShanghai 需要注意的是language 和timezone ，语言和时区。 这里： 1theme: huno huno是我下载的主题，放在{目录}/theme/huno下。 最重要的是1234deploy type: git repo: git@github.comDrazen08Drazen08.github.io.git branch: master repo的地址是ssl形式的，其实好像不用这么麻烦，或许是我被墙了。。 最后执行hexo deploy 在浏览器中输入 你自己的.github.io 就可以访问了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate hexo deploy 一些常用命令：hexo newpostName #新建文章 hexo new pagepageName #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，ctrl + c关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 对了，当时好像我配置了一个ssh码关联到github上，忘记了。","categories":[],"tags":[{"name":"Hexo_Github","slug":"Hexo-Github","permalink":"http://sunjx93.com/tags/Hexo-Github/"}]}]}